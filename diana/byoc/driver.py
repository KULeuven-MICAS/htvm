from tvm.driver.tvmc.model import TVMCModel
from typing import Dict
from abc import ABC, abstractmethod
import tvm
import utils
import numpy as np
import profiler
import subprocess
import pathlib
import shutil

import mlperf_tiny.relay_ds_cnn
import mlperf_tiny.relay_mobilenet
import mlperf_tiny.relay_resnet
import mlperf_tiny.relay_dae

import tvm.relay as relay


class Driver(ABC):
    """ Abstract base class for HTVM Driver code

    Classes that inherit from this class implement a common interface to drive
    compilation, profiling and running of HTVM-generated code.

    NOTE: Some of the methods can not be called consecutively.
    This is the order in which you can call them:
    1) tvm_compile
    2) (add_profiler)
    3) gcc_compile
    4) run
    5) (process_profile)

    :param mod: TVM IRModule for the network to be compiled
    :param params: dictionary of weights to be used in network
    :param build_dir: directory in which the code will be put, built and ran.
    :param byoc_path: directory that contains necessary files to import.
        Some files that can be imported include Makefiles, headers, and 
        libraries.
    :param no_of_inputs: amount of inputs for the IR module.
        This information is necessary in for generating C wrapper code in
        build_dir/src/demo.c.
    """
    def __init__(self,
                 mod: tvm.ir.IRModule,
                 params: Dict[str, tvm.nd.array],
                 build_dir: pathlib.Path = "build",
                 byoc_path: pathlib.Path = ".",
                 no_of_inputs: int = 1):
        """Constructor method
        """
        self.model = TVMCModel(mod, params)
        self.build_dir = build_dir
        self.byoc_path = byoc_path
        self.no_of_inputs = no_of_inputs

    @abstractmethod
    def tvm_compile(self, 
                    fusion: bool = False,
                    init_value: int = 1):
        """Compiles network to C code with TVM

        This is a wrapper method around TVMC that generates C code for the 
        network and C code that calls the network.
        All output is stored in self.build_dir

        :param fusion: Enable/Disable operator fusion pass for TVM generated
            kernels
        :param init_value: input value set in calling wrapper
        """
        raise NotImplementedError()

    @abstractmethod
    def gcc_compile(self, gcc_opt: int = 3):
        """Compiles C code to self-contained binary with GCC
        
        This is a wrapper method around GCC that compiles the C code generated
        by the tvm_compile method in self.build_dir
        
        :param gcc_opt: gcc's optimization flag (e.g. -O3)

        NOTE: This method will fail if it is not called after tvm_compile
        """
        raise NotImplementedError()

    def add_profiler(self):
        """Adds profiling code to TVM-generated C code
        
        If implemented, this method adds profiling C-stubs to TVM-generated
        C-code. Profiling output is generated by the run method and also 
        put in self.build_dir.
        
        NOTE: This method will fail if it is not called after tvm_compile
        """
        raise NotImplementedError()

    @abstractmethod
    def run(self):
        """Runs generated binary (and collects profiling information)
        
        This method runs the generated binary and collects profiling 
        information if the binary was gcc_compiled with added profilers from
        the add_profiler method.

        NOTE: This method will fail if it is not called after gcc_compile
        No profiler output is generated in self.build_dir if the C code was
        not compiled with profiling stubs from the add_profiler method

        :return: output of the network
        """
        raise NotImplementedError()

    def process_profile(self):
        """Post-processes profiling information
        
        If implemented, this method post-processes profiling information
        generated by run in self.build_dir by C code that has profiling stubs.
        """
        raise NotImplementedError()


class X86Driver(Driver):
    def __init__(self,
                 mod: tvm.ir.IRModule,
                 params: Dict[str, tvm.nd.array],
                 build_dir: pathlib.Path = "build",
                 byoc_path: pathlib.Path = ".",
                 no_of_inputs: int = 1):
        super(X86Driver, self).__init__(mod, params, build_dir, byoc_path, no_of_inputs)
        self.device = "x86"
        self.build_dir = self.build_dir / self.device
        self.target = "c"
        utils.create_build_dir(self.byoc_path, self.build_dir, self.device)

    def tvm_compile(self, fusion: bool = False, init_value: int = 1):
        utils.tvmc_compile_and_unpack(self.model, target=self.target,
                                      fuse_layers=fusion,
                                      byoc_path=self.byoc_path,
                                      build_path=self.build_dir)
        utils.create_demo_file(self.model.mod, init_value=init_value,
                               no_of_inputs=self.no_of_inputs,
                               directory=self.build_dir)

    def gcc_compile(self, gcc_opt: int = 0):
        utils.adapt_gcc_opt(self.build_dir/"Makefile.x86", gcc_opt)
        utils.make(self.device, make_dir=self.build_dir)

    def run(self):
        result_x86 = utils.gdb(device=self.device, binary="demo",
                               gdb_script="gdb_demo_x86.sh",
                               directory=self.build_dir)
        return result_x86

class DianaDriver(Driver):
    def __init__(self,
                 mod: tvm.ir.IRModule,
                 params: Dict[str, tvm.nd.array],
                 build_dir: pathlib.Path = "build",
                 byoc_path: pathlib.Path = ".",
                 no_of_inputs: int = 1):
        super(DianaDriver, self).__init__(mod, params, build_dir, byoc_path, no_of_inputs)
        self.device = "pulp"
        self.build_dir = self.build_dir / self.device
        # TODO: move -requant_transform somewhere else?
        self.target="soma_dory -requant_transform=0, c"
        self.init_value = 1
        # Placeholders in case profiling code is added
        self.kernels = None
        self.measurement = None
        utils.create_build_dir(self.byoc_path, self.build_dir, self.device)

    def tvm_compile(self, 
                    fusion: bool = True,
                    init_value: int = 1,
                    indefinite: bool = False,
                    boot_analog: bool = False,
                    ):
        """Compiles network to C code with TVM

        This is a wrapper method around TVMC that generates C code for the 
        network and C code that calls the network.
        All output is stored in self.build_dir

        :param fusion: Enable/Disable operator fusion pass for TVM generated
            kernels
        :param init_value: input value set in calling wrapper
        :param indefinite: put infinite loop around TVM network. Useful for
            power measurements.
        :param boot_analog: put analog core boot code in C wrapper before
            calling TVM generated code.
        """
        utils.tvmc_compile_and_unpack(self.model, target=self.target,
                                      fuse_layers=fusion,
                                      byoc_path=self.byoc_path,
                                      build_path=self.build_dir)
        # This temporary file is generated in the previous function and is
        # used for processing the output of individual profiling data
        shutil.copyfile("/tmp/macs_report.txt",self.build_dir/"macs_report.txt")
        utils.create_demo_file(self.model.mod, 
                               init_value=self.init_value,
                               no_of_inputs=self.no_of_inputs,
                               directory=self.build_dir)
    def gcc_compile(self, gcc_opt: int = 3):
        utils.adapt_gcc_opt(self.build_dir/"Makefile.pulprt", gcc_opt)
        utils.make(self.device, make_dir=self.build_dir)

    def add_profiler(self, measurement):
        """Adds profiling code to TVM-generated C code
        
        This method adds profiling C-stubs to TVM-generated
        C-code. Profiling output is generated by the run method and also 
        put in self.build_dir.

        :param measurement: choose between "invidividual" and "global"
            "individual" measures individual kernel performance
            "global" measures the performance of the entire network
        
        NOTE: This method will fail if it is not called after tvm_compile
        NOTE: This method stores kernels and measurement attributes in the
            object which is needed later for process_profile
        """
        self.measurement = measurement
        self.kernels = profiler.insert_profiler(
                codegen_dir = self.build_dir/"codegen/host/src/",
                gdb_script_name = self.build_dir/"./gdb_demo.sh",
                csv_file = self.build_dir/"profile.csv",
                gdb_log_name = self.build_dir/"profile.txt",
                interactive = False,
                measurement = "measurement")
        _ = profiler.insert_profiler(
                codegen_dir = self.build_dir/"/codegen/host/src/",
                gdb_script_name = self.build_dir/"gdb_demo.sh",
                csv_file = self.build_dir/"memory.csv",
                gdb_log_name= self.build_dir/"memory.txt",
                interactive = False,
                measurement = "memory")

    def process_profile(self):
        cycles = profiler.process_profiler(
                            measurement=self.measurement, 
                            kernels=self.kernels,
                            log_file=self.build_dir/"profile.txt",
                            csv_file=self.build_dir/"profile.csv",
                            macs_report = self.build_dir/"macs_report.txt")
        heap_usage = profiler.process_profiler(
                            measurement="memory", 
                            kernels=None,
                            log_file=self.build_dir/"memory.txt",
                            csv_file=self.build_dir/"memory.csv")
    def run(self):
        result = utils.gdb(device=self.device, 
                           binary="pulpissimo/demo/demo",
                           gdb_script="gdb_demo.sh",
                           directory=self.build_dir)
        return result


def driver(mod: tvm.ir.IRModule, 
           params: Dict[str, tvm.nd.array],
           run: bool = False, build_dir: pathlib.Path = "build",
           byoc_path: pathlib.Path = ".",
           no_of_inputs: int = 1):
    """
    Compile (and run) a model for DIANA for testing purposes

    If the run argument is used, then it will also run the compiled model
    on a remote GDB instance over port 3333.
    Afterwards an x86 compiled model is used to compare outputs
    """
    # Create a TVMCModel
    model = TVMCModel(mod, params)
    # Create the model library format file and unpack
    d_diana = DianaDriver(mod, params, build_dir=build_dir,
                          byoc_path=byoc_path, no_of_inputs=no_of_inputs)
    d_diana.tvm_compile(fusion=True)
    d_diana.add_profiler(measurement="global")
    d_diana.gcc_compile(gcc_opt=3)
    # Make for DIANA
    if run:
        # Run the binary on DIANA
        output_pulp = d_diana.run()
        d_diana.process_profile()
        # Compile and run the network on x86
        d_x86 = X86Driver(mod, params, build_dir, byoc_path, no_of_inputs)
        d_x86.tvm_compile(fusion=False)
        d_x86.gcc_compile(gcc_opt=0)
        output_x86 = d_x86.run()
        # Compare X86 and DIANA outputs
        # Use allclose, not allequal (in case of floats)
        assert np.ma.allclose(output_x86,output_pulp)



def run_network_diana(name, f_create_model, precision, mixed, pulp_target, measurement="global", result_x86=None):
    np.random.seed(0)
    mod, params = f_create_model(precision, True, mixed)
    model = TVMCModel(mod, params)
    init_value = 1
    verification = None
    # run on Diana
    print("TEST: compiling for Diana")
    device = "pulp"
    fusion = True
    utils.tvmc_compile_and_unpack(model, target=pulp_target, fuse_layers=fusion)
    # Add analog boot code in case of precision
    if precision == 2 or mixed:
        utils.create_demo_file(mod, init_value=init_value, boot_analog=True)
        utils.adapt_gcc_opt("Makefile.pulprt", 3)
    else:
        utils.create_demo_file(mod, init_value=init_value)
        utils.adapt_gcc_opt("Makefile.pulprt", 3)
    kernels = profiler.insert_profiler(codegen_dir = "./build/codegen/host/src/",
                                       gdb_script_name = "./gdb_demo.sh",
                                       csv_file = "profile.csv",
                                       interactive = False,
                                       measurement = measurement)
    _ = profiler.insert_profiler(codegen_dir = "./build/codegen/host/src/",
                                       gdb_script_name = "./gdb_demo.sh",
                                       csv_file = "memory.csv",
                                       gdb_log_name= "memory.txt",
                                       interactive = False,
                                       measurement = "memory")
    try:
        utils.make(device)
    except subprocess.CalledProcessError:
        return {"name": name,
                "compilation": False, 
                "run": None, 
                "verification": None, 
                "cycles": None, 
                "heap_usage": None, 
                "size_dict": None}
    size_dict = utils.size_pulp("build/pulpissimo/demo/demo")
    if precision == 2 or mixed:
        log = pathlib.Path("demo.txt")
        # Remove previous log before proceeding
        log.unlink(missing_ok=True)
        input("Please continue the measurement manually... And press enter")
        result_pulp = utils.get_gdb_output("demo.txt")
    else:
        try:
            result_pulp = utils.gdb(device, "build/pulpissimo/demo/demo", "gdb_demo.sh")
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            return {"name": name,
                    "compilation": True,
                    "run": False, 
                    "verification": None, 
                    "cycles": None, 
                    "heap_usage": None, 
                    "size_dict": size_dict}
            print("TEST: obtaining Diana output")
            print(result_pulp)

    if precision == 2 or mixed:
        print("TEST: Verification for int2 is not supported on X86")
    else:
        print("Final Results")
        print("=============")
        print("X86 output:")
        print(result_x86)
        print("Diana output:")
        print(result_pulp)
        # use allclose for floating point values
        try:
            if np.ma.allclose(result_x86,result_pulp):
                print("TEST: PASS")
                verification = True
            else:
                print("TEST: FAIL")
                verification = False
        except Exception as e:
            verification = None

    cycles = profiler.process_profiler(measurement, kernels)
    heap_usage = profiler.process_profiler("memory", kernels=None,
                                              log_file="memory.txt",
                                              csv_file="memory.csv")
    print(size_dict)
    return {"name": name,
            "compilation": True,
            "run": True, 
            "verification": verification, 
            "cycles": cycles, 
            "heap_usage": heap_usage, 
            "size_dict": size_dict}

def print_results(result_dict):
    if type(result_dict['cycles']) == int:
        print(f"\tcycles: {result_dict['cycles']:,} cyc")
    elif result_dict['cycles'] is None:
        print(f"\tcycles: {result_dict['cycles']}")
    else:
        result_dict['cycles'].pretty_print()
        print("\n")
        result_dict['cycles'].print_total_cycles()
    print(f"run: {result_dict['name']}")
    print(f"\tcompld: {result_dict['compilation']}")
    print(f"\trunned: {result_dict['run']}")
    print(f"\tverifd: {result_dict['verification']}")
    if result_dict['heap_usage'] is None:
        print(f"\tpeakl2: {result_dict['heap_usage']}")
    else:
        print(f"\tpeakl2: {result_dict['heap_usage'][0]:,} bytes")
        print(f"\t@endl2: {result_dict['heap_usage'][1]:,} bytes")
    if result_dict["compilation"] is None or result_dict["compilation"] == False:
        print(f"\tstatl2: {result_dict['size_dict']}")
    else:
        print(f"\tstatl2: {result_dict['size_dict']['total']:,} bytes")
        print(f"\tstatl2: {result_dict['size_dict']['total']:,} bytes")
        print(f"\t\tTEXT: {result_dict['size_dict']['text']:,} bytes")
        print(f"\t\tDATA: {result_dict['size_dict']['data']:,} bytes")
        print(f"\t\tBSS : {result_dict['size_dict']['bss']:,} bytes")




if __name__ == "__main__":
    # Test settings
    network_under_test = mlperf_tiny.relay_resnet
    precision = 2
    mixed = False
    measurement = "global"
    name = "relay_resnet_no_ews"
    setting = "HTVM_opt_no_dma"
    experiment_name = pathlib.Path(f"{name}_{measurement}_{precision}_bits_{setting}")
    folder = pathlib.Path("results")
    exp_folder = folder / experiment_name
    if precision == 2 and not mixed:
        test_target ="soma_dory -layout_transform=0 -disable_digital_acc=1, c"
    else:
        test_target ="soma_dory -layout_transform=0, c"
    #test_target ="c"

    network_file = pathlib.Path(network_under_test.__file__)
    network_create = network_under_test.create_model
    try:
        exp_folder.mkdir(parents=True)
    except FileExistsError as e:
        print(e)
        print(f"You are about to overwrite {exp_folder}, are you sure?")
        response = input("Type 'yes' to proceed...")
        if response != "yes":
            print("Did not get 'yes', exiting...")
            exit(1)
        shutil.rmtree(exp_folder)
        exp_folder.mkdir(parents=True)

    if precision == 8:
        #result_x86 = run_network_x86('manual_test_x86', network_create)
        result_x86 = None
    else:
        result_x86 = None
    result_dict =  run_network_diana(f"final_testing", network_create, precision, mixed, test_target, measurement, result_x86)
    print_results(result_dict) 
    print(f"Copying all results to {exp_folder}")
    shutil.copyfile(network_file, exp_folder/network_file.name)
    shutil.copytree(pathlib.Path("build"), exp_folder/"build")
    shutil.copytree(pathlib.Path("dory"), exp_folder/"dory")
    shutil.copytree(pathlib.Path("src"), exp_folder/"src")
    shutil.copytree(pathlib.Path("include"), exp_folder/"include")
    shutil.copyfile(network_file, exp_folder/network_file.name)
    shutil.copyfile("Makefile.pulprt", exp_folder/"Makefile.pulprt")
    try:
        shutil.copyfile("demo_x86.txt",exp_folder/"demo_x86.txt")
        shutil.copyfile("demo.txt",exp_folder/"demo.txt")
        shutil.copyfile("memory.csv",exp_folder/"memory.csv")
        shutil.copyfile("profile.csv",exp_folder/"profile.csv")
        shutil.copyfile("macs.csv",exp_folder/"macs.csv")
        # Remove macs.csv after copy!
        pathlib.Path("macs.csv").unlink(missing_ok=True)
    except FileNotFoundError as e:
        print(e)
