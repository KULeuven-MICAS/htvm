/********************************** METADATA **********************************/

/*
* Contributors: Vincent Tableau Roche
* Contacts: vincent.tableau@esat.kuleuven.be
* Creation Date: 2021-02-24
* Language: C++ Source Code
*/

/********************************** INCLUDES **********************************/

#include "codegen_sirius.h"	// The codegen we are implementing

/*********************************** METHODS **********************************/

namespace tvm {
namespace codegen {

CodeGenSirius::CodeGenSirius() {
	// Giving a name to the module.
	module_name_ = GetUniqueName("__tvm_sirius_module");
}

void CodeGenSirius::Init(bool output_ssa) {
  // Clearing the global variables from previous module compilation.
  declared_globals_.clear();
  // Adding small explanatory comment.
  decl_stream << "// Code automatically generated by TVM for the SIRIUS platform" << std::endl;
  // Adding includes for the TVM types.
  decl_stream << "#include \"tvm/runtime/c_runtime_api.h\"" << std::endl;
  decl_stream << "#include \"tvm/runtime/c_backend_api.h\"" << std::endl;
  // Including the soma hardware acceleration library.
  decl_stream << "#include <soma.h>" << std::endl;
  decl_stream << "#include <math.h>" << std::endl;
  // Adding a newline for the style.
  decl_stream << std::endl;
  decl_stream << "void* " << module_name_ << " = NULL;" << std::endl;
  // Adding a newline for the style.
  decl_stream << std::endl << std::endl;
  // Calling parent method.
  CodeGenC::Init(output_ssa);
}

void CodeGenSirius::AddFunction(const PrimFunc& f) {
	// Getting the name of the function.
	auto global_symbol = f->GetAttr<String>(tvm::attr::kGlobalSymbol);
	ICHECK(global_symbol.defined())
	    << "CodeGenCHost: Expect PrimFunc to have the global_symbol attribute";
	function_names_.push_back(global_symbol.value());

	// Calling parent method.
	CodeGenC::AddFunction(f);
}

void CodeGenSirius::PrintFuncPrefix() {
  // Adapted from CodeGenCHost, this makes it so that our functions have return type int32_t. The declaration of a function is never indented.
  stream << "TVM_DLL int32_t";
}

void CodeGenSirius::PrintFinalReturn() {
  // Taken from CodeGenCHost, this makes it so that the functions return 0 when the successfully exit.
  this->PrintIndent();
  stream << "return 0;\n";
}


Array<String> CodeGenSirius::GetFunctionNames() {
	// Return the names of the functions added to this module.
	return function_names_;
}

void CodeGenSirius::VisitStmt_(const AssertStmtNode* op) {
	// Ignoring assertions for now, we just move on to the next node.
  	this->PrintStmt(op->body);
}

void CodeGenSirius::VisitExpr_(const CallNode* op, std::ostream& os) {
  // Implementation of the missing functions from CodeGenC, copied from CodeGenCHost.
  if (op->op.same_as(builtin::tvm_throw_last_error())) {
    this->PrintIndent();
    // We return -1 to signal an error to our caller.
    this->stream << "return -1;\n";
  } else {
    CodeGenC::VisitExpr_(op, os);
  }
}

void CodeGenSirius::VisitExpr_(const MinNode* op, std::ostream& os) {
  // First, we have to read the two operands of the min operation.
  std::ostringstream temp_a;
  VisitExpr(op->a, temp_a);
  // To avoid name collisions, we get the unique ID for the first operand.
  std::string a_id = SSAGetID(temp_a.str(), op->a.dtype());
  // Same for the second operand, we start by getting its name.
  std::ostringstream temp_b;
  VisitExpr(op->b, temp_b);
  // We get the unique ID of the second operand.
  std::string b_id = SSAGetID(temp_b.str(), op->b.dtype());

  // Then, we fill the provided osstream with the ternary operation to get the expected minimum. The additionnal "()" are here to avoid ambiguity in case a_id or b_id also contain operations.
  os << "((" << a_id << ") < (" << b_id << ") "
     << "? (" << a_id << ") : (" << b_id << "))";
}

void CodeGenSirius::VisitExpr_(const MaxNode* op, std::ostream& os) {
  // First, we have to read the two operands of the max operation.
  std::ostringstream temp_a;
  VisitExpr(op->a, temp_a);
  // To avoid name collisions, we get the unique ID for the first operand.
  std::string a_id = SSAGetID(temp_a.str(), op->a.dtype());
  // Same for the second operand, we start by getting its name.
  std::ostringstream temp_b;
  VisitExpr(op->b, temp_b);
  // We get the unique ID of the second operand.
  std::string b_id = SSAGetID(temp_b.str(), op->b.dtype());

  // Then, we fill the provided osstream with the ternary operation to get the expected maximum. The additionnal "()" are here to avoid ambiguity in case a_id or b_id also contain operations.
  os << "((" << a_id << ") > (" << b_id << ") "
     << "? (" << a_id << ") : (" << b_id << "))";
}

/********************************** FUNCTIONS *********************************/

// Entry point of the backend for TVM, adapted from codegen_c_host.cc
runtime::Module BuildSirius(IRModule mod, Target target) {
  using tvm::runtime::Registry;
  bool output_ssa = false;
  CodeGenSirius cg;
  cg.Init(output_ssa);

  for (auto kv : mod->functions) {
    // Adding the function to the codegen
    ICHECK(kv.second->IsInstance<PrimFuncNode>()) << "CodegenSirius: Can only take PrimFunc";
    auto f = Downcast<PrimFunc>(kv.second);
    cg.AddFunction(f);
  }

  std::string code = cg.Finish();
  return CSourceModuleCreate(code, "c", cg.GetFunctionNames());
}

TVM_REGISTER_GLOBAL("target.build.sirius").set_body_typed(BuildSirius);
}  // namespace codegen
}  // namespace tvm

/************************************ EOF *************************************/
